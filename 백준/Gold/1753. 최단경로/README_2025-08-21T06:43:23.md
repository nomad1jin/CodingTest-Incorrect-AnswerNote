# [Gold IV] ìµœë‹¨ê²½ë¡œ - 1753 

[ë¬¸ì œ ë§í¬](https://www.acmicpc.net/problem/1753) 

### ë¶„ë¥˜

ê·¸ë˜í”„ ì´ë¡ , ìµœë‹¨ ê²½ë¡œ, ë°ì´í¬ìŠ¤íŠ¸ë¼

### ë¬¸ì œ ì„¤ëª…

<p>ë°©í–¥ê·¸ë˜í”„ê°€ ì£¼ì–´ì§€ë©´ ì£¼ì–´ì§„ ì‹œì‘ì ì—ì„œ ë‹¤ë¥¸ ëª¨ë“  ì •ì ìœ¼ë¡œì˜ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤. ë‹¨, ëª¨ë“  ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ëŠ” 10 ì´í•˜ì˜ ìì—°ìˆ˜ì´ë‹¤.</p>

### ì…ë ¥ 

 <p>ì²«ì§¸ ì¤„ì— ì •ì ì˜ ê°œìˆ˜ Vì™€ ê°„ì„ ì˜ ê°œìˆ˜ Eê°€ ì£¼ì–´ì§„ë‹¤. (1 â‰¤ V â‰¤ 20,000, 1 â‰¤ E â‰¤ 300,000) ëª¨ë“  ì •ì ì—ëŠ” 1ë¶€í„° Vê¹Œì§€ ë²ˆí˜¸ê°€ ë§¤ê²¨ì ¸ ìˆë‹¤ê³  ê°€ì •í•œë‹¤. ë‘˜ì§¸ ì¤„ì—ëŠ” ì‹œì‘ ì •ì ì˜ ë²ˆí˜¸ K(1 â‰¤ K â‰¤ V)ê°€ ì£¼ì–´ì§„ë‹¤. ì…‹ì§¸ ì¤„ë¶€í„° Eê°œì˜ ì¤„ì— ê±¸ì³ ê° ê°„ì„ ì„ ë‚˜íƒ€ë‚´ëŠ” ì„¸ ê°œì˜ ì •ìˆ˜ (u, v, w)ê°€ ìˆœì„œëŒ€ë¡œ ì£¼ì–´ì§„ë‹¤. ì´ëŠ” uì—ì„œ vë¡œ ê°€ëŠ” ê°€ì¤‘ì¹˜ wì¸ ê°„ì„ ì´ ì¡´ì¬í•œë‹¤ëŠ” ëœ»ì´ë‹¤. uì™€ vëŠ” ì„œë¡œ ë‹¤ë¥´ë©° wëŠ” 10 ì´í•˜ì˜ ìì—°ìˆ˜ì´ë‹¤. ì„œë¡œ ë‹¤ë¥¸ ë‘ ì •ì  ì‚¬ì´ì— ì—¬ëŸ¬ ê°œì˜ ê°„ì„ ì´ ì¡´ì¬í•  ìˆ˜ë„ ìˆìŒì— ìœ ì˜í•œë‹¤.</p>

### ì¶œë ¥ 

 <p>ì²«ì§¸ ì¤„ë¶€í„° Vê°œì˜ ì¤„ì— ê±¸ì³, ië²ˆì§¸ ì¤„ì— ië²ˆ ì •ì ìœ¼ë¡œì˜ ìµœë‹¨ ê²½ë¡œì˜ ê²½ë¡œê°’ì„ ì¶œë ¥í•œë‹¤. ì‹œì‘ì  ìì‹ ì€ 0ìœ¼ë¡œ ì¶œë ¥í•˜ê³ , ê²½ë¡œê°€ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ê²½ìš°ì—ëŠ” INFë¥¼ ì¶œë ¥í•˜ë©´ ëœë‹¤.</p>



#  ğŸš€  ì˜¤ë‹µë…¸íŠ¸ 

```diff
import java.util.*;
import java.io.*;

-class Node {
+class Node implements Comparable<Node>{
    
    private int index;
    private int distance;
    
    public Node(int index, int distance){
        this.index = index;
        this.distance = distance;
    }
    
    public int getIndex(){
        return this.index;
    }
    public int getDistance(){
        return this.distance;
    }
+    
+    @Override
+    public int compareTo(Node other){
+        // return this.distance - other.distance;
+        return Integer.compare(this.distance, other.distance);
+    }
}

public class Main {
    
    public static final int INF = (int) 1e9;
    public static ArrayList<ArrayList<Node>> graph = new ArrayList<ArrayList<Node>>();
    public static boolean visited[] = new boolean[100001];
    public static int d[] = new int[100001];
    public static int V, E;
-        
-    //ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œ ì¤‘ì—ì„œ ê±°ë¦¬ê°€ ì œì¼ ì§§ì€ ë…¸ë“œì˜ ì¸ë±ìŠ¤ ë°˜í™˜ 
-    public static int getSmallestNode(){
-        int min = INF;
-        int index = 0;
-        visited[index] = true;
-        for(int i=1; i<=V; i++){
-            if(d[i] < min && !visited[i]){
-                min = d[i];
-                index = i;
-            }
-        }
-        return index;
-    }
    
    public static void dijkstra(int start){
-        //ì‹œì‘ ë…¸ë“œ ì´ˆê¸°í™” - d ì´ˆê¸°í™”ë„ í•„ìš”í•œê°€?
+    
+        // PriorityQueue<Node> pq = new PriorityQueue<>((o1, o2) -> o1.distance - o2.distance);
+        PriorityQueue<Node> pq = new PriorityQueue<>();
+        pq.offer(new Node(start, 0));   //ì‹œì‘ì  ìì‹ ì€ 0ìœ¼ë¡œ ì¶œë ¥í•˜ê¸° 
        d[start] = 0;
-        visited[start] = true;
-        for(int i=0; i<graph.get(start).size(); i++){
-            d[graph.get(start).get(i).getIndex()] = graph.get(start).get(i).getDistance();
-        }
-        
-        //ì‹œì‘ ë…¸ë“œë¥¼ ì œì™¸í•œ ë‚˜ë¨¸ì§€
-        for(int i=0; i<V-1; i++){
-            int now = getSmallestNode();
-            visited[now] = true;
+        while(!pq.isEmpty()){
+
+            //ìµœë‹¨ê±°ë¦¬ ì •ë³´ êº¼ë‚´ê¸° 
+            Node node = pq.poll();
+            int now = node.getIndex();
+            int dis = node.getDistance();
+            if(d[now] < dis) continue;   //ì´ë¯¸ ì²˜ë¦¬ëœ ì  ìˆë‹¤ë©´ ì»¨í‹°ë‰´ ì´ë ‡ê²Œ???
+                
            for(int j=0; j<graph.get(now).size(); j++){
                //ê±°ë¦¬ ë¹„êµ, costì— d[now]ìŠì§€ ë§ê¸° 
+                int otherIndex = graph.get(now).get(j).getIndex();
                int cost = d[now] + graph.get(now).get(j).getDistance();
-                if(cost < d[graph.get(now).get(j).getIndex()]){
-                    d[graph.get(now).get(j).getIndex()] = cost;
+                if(cost < d[otherIndex]){
+                    d[otherIndex] = cost;
+                    //pqì—ë„ costê°±ì‹ 
+                    pq.offer(new Node(otherIndex, cost));
                }
            }
        }
+        
    }
    
    
    public static void main(String[] args) throws IOException {
        
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        V = Integer.parseInt(st.nextToken());
        E = Integer.parseInt(st.nextToken());
        int start = Integer.parseInt(br.readLine());
        
        //ê·¸ë˜í”„ ì´ˆê¸°í™” (ë…¸ë“œëŠ” 1ë¶€í„° Vê°œì„, <=Vì„ì„ ìŠì§€ë§ê²ƒ)
        for(int i=0; i<=V; i++){
            graph.add(new ArrayList<Node>());
        }
        
        for(int i=0; i<E; i++){
            st = new StringTokenizer(br.readLine(), " ");
            int u = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            int w = Integer.parseInt(st.nextToken());
            graph.get(u).add(new Node(v, w));
        }
        
        Arrays.fill(d, INF);
        dijkstra(start);
        
        StringBuilder sb = new StringBuilder(); 
-        for(int i=0; i<=V; i++){
-            if(i == start){
-                sb.append("0\n");
-            } else if(d[i] == INF){
-                sb.append("INF\n");
+        for(int i=1; i<=V; i++){
+            if(d[i] == INF){
+                // sb.append("INF\n");
+                System.out.println("INF");
            } else {
-                sb.append(d[i]).append("\n");
+                // sb.append(d[i]).append("\n");
+                System.out.println(d[i]);
            }
        }
-        System.out.println(sb);
+        // System.out.println(sb);
    }
}

```

# ğŸ’» ì½”ë“œ ë¦¬ë·°




 ## ğŸ† ë©”ëª¨ 

ì´ ë¬¸ì œëŠ” ë‹¤ìµìŠ¤íŠ¸ë¼ë¥¼ ì‚¬ìš©í•˜ëŠ” ê³¨ë“œ 4 ë¬¸ì œì´ë‹¤.
- ì´ í’€ì´ëŠ” 4ë²ˆì„ í‹€ë¦¬ë©´ì„œ ì™„ì„±ë  ìˆ˜ ìˆì—ˆë‹¤.... ì—¬ëŸ¬ í¬ì¸íŠ¸ê°€ ìˆì—ˆëŠ”ë°, ì°¨ê·¼ ì°¨ê·¼ ë§í•´ë³´ê² ë‹¤.
- ë™ë¹ˆë‚˜ í’€ì´ëŠ” ArrayList<ArrayList<Integer> graphì´ëŸ°ì‹ìœ¼ë¡œ ì‚¬ìš©í•œë‹¤. ìµœê·¼ ë¸”ë¡œê·¸ í’€ì´ì—ì„ , ArrayList<Node> graphë¡œ ì •ì˜í•´ë‘ê³  ë°°ì—´ ì´ˆê¸°í™” ë•Œ graph[i] = new ArrayList<>(); ì´ëŸ°ì‹ìœ¼ë¡œ ì§„í–‰í•˜ë”ë¼. (ì·¨í–¥ ì°¨ì´ì¸ë“¯)
- ì–´ë–¤ í’€ì´ì—ì„  ìŠ¤íŠ¸ë¦¼ ë¬¸ë²•ìœ¼ë¡œ Comparatorì„ ì•„ì£¼ ì‰½ê²Œ ì“°ê¸°ë„ í–ˆë‹¤. PriorityQueue<Node> pq = new PriorityQueue<>((o1, o2) -> o1.distance - o2.distance); 
- ê·¼ë° ì´ë ‡ê²Œ í•˜ë©´ ë‹¨ì ì´ ìˆëŠ”ê²Œ, ë‹¤ë¥¸ í´ë˜ìŠ¤ ì•ˆì˜ ë³€ìˆ˜ëŠ” ë³´í†µ privateìœ¼ë¡œ í•˜ê¸°ì—(ìº¡ìŠí™”, ì€ë‹‰) ë‚˜ì˜ ê²½ìš°ì—ëŠ” ì‚¬ìš©í•˜ì§€ ì•Šì•˜ë‹¤. ê·¸ì¹˜ë§Œ í›¨ì”¬ ê¹”ë”í•˜ê³  ì¢‹ì•˜ë‹¤
- while ë°˜ë³µë¬¸ ë‚´ì—ì„œ if(d[now] < dis) continue; ì„ ë„£ì–´ ì„±ëŠ¥ì„ í™•ë³´í•  ìˆ˜ ìˆì—ˆë‹¤. (PriorityQueueëŠ” íì— ë“¤ì–´ì˜¨ ì‹œì ì—ì„œì˜ ê±°ë¦¬ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ë§Œ í•¨. ë‚˜ì¤‘ì— ë” ì§§ì€ ê±°ë¦¬ë¡œ ê°±ì‹ ë  ìˆ˜ ìˆìŒ)
