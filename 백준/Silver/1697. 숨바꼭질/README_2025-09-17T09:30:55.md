# [Silver I] 숨바꼭질 - 1697 

[문제 링크](https://www.acmicpc.net/problem/1697) 

### 분류

그래프 이론, 그래프 탐색, 너비 우선 탐색

### 문제 설명

<p>수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.</p>

<p>수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.</p>

### 출력 

 <p>수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.</p>



#  🚀  오답노트 

```diff
import java.util.*;

public class Main {
    
+    public static Queue<Integer> q = new LinkedList<>();
+    public static int[] count = new int[100001];
+    public static int[] dMove = {-1, 1, 2};
+    public static int K, N;
+    
    public static void main(String[] args) {
        
        // 수빈이의 위치에서 3가지 선택지를 가지게된다
        Scanner sc = new Scanner(System.in);
-        int N = sc.nextInt();
-        int K = sc.nextInt();
+        N = sc.nextInt();
+        K = sc.nextInt();
        
-        //노드의 수를 모르는데 어떻게 graph.add(new ArrayList<>()); 하지? 
-        //dp처럼 일단 큰수를 만들고 시작 
-        
-        int[] count = new int[100001];
-        int[] dMove = {-1, 1, 2};
-        Queue<Integer> q = new LinkedList<>();
        q.offer(N);
        count[N] = 1;
        
+        if(N == K){
+            System.out.println(0);  //첨부터 같으면 0 
+        } else {
+            bfs();
+        }
+    }
+    
+    public static void bfs(){
        while(!q.isEmpty()){
            
            int temp = q.poll();
            int next;
            
            // 반복문으로 -1, 1, 2배의 경우를 계산하기
            for(int i=0; i<dMove.length; i++){
                if(i == 2){
                    next = temp * dMove[i];
-                } else if(i==1){
-                    next = temp + 1;
                } else {
-                    next = temp - 1;
+                    next = temp + dMove[i];    //-1, 1의 경우
                }
                
                //만약 같다면 현재 카운트를 프린트하고 바로 리턴
                if(next == K){
                    System.out.println(count[temp]);
                    return;
                }
                
                //계속 진행하려면? 카운트가 0인걸 방문해야됨
                if(next >= 0 && next < count.length && count[next] == 0){
                    q.add(next);
                    count[next] = count[temp] + 1;  //이전까지의 카운트를 누적할 수 있도록
                    // 음수 방지하고, 배열 인덱스 ~100000까지를 해서 보다 적은 수를 사용
                }
                
            }   
        }
    }
}

```

# 💻 코드 리뷰




 ## 🏆 메모 

- 일단 배열을 활용해서 **dMove로 -1, 1, 2**를 나타낸게 이 풀이의 핵심이라 생각한다
- BFS 문제임을 알고있었음에도 처음엔 이해가 안 됐다.. 내가 알던 형태가 아니야! 그런데 왜 최단경로에 BFS를 사용하는지는 좀 이해가 됐다.
- while, for반복문 안에서 다음 숫자 증감과 동시에 종결식, 꾸준한 반복문 코드가 있다. 
- 배열인덱스가 0~100000이므로 이 길이를 이용해서 더 작은숫자이면서 음수가 아니어야하고, 방문안한 경우를 큐에 넣어준다.
- 만약 next가 **음수**이면 **ArrayIndexOutOfBoundsException** 가 터지니 유의하자. 
- 만약 **N==K이면 0을 프린트해줘야한다.** 이를 계속 놓쳐서 이 문제를 3번이나 틀렸다.